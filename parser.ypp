%{

//User Declarations

#include "output.hpp"
#include "parser.hpp"

int yylex();
void yyerror(const char*);

extern int yylineno;    //line number from lex for Errors

//Global Variables

std::stack<SymbolTable> TableStack;
std::stack<int> OffsetStack;
bool isAprintFunc;           //special case for the print function
RetType* expectedRet;        ////current fun expected return type for checking
Id* currentFunName;            //current fun name
Formals* currentFunParams;   //current fun params for type checking
int whileScopes;             //current number of while scopes 

%}

//Declarations

%token VOID
%token INT;
%token BYTE;
%token B;
%token BOOL;
%left AND;
%left OR;
%right NOT;
%token TRUE;
%token FALSE;
%token RETURN;
%token WHILE;
%token BREAK;
%token SC;
%token COMMA;
%left LPAREN;
%left RPAREN;
%nonassoc ELSE;
%token IF;
%left LBRACE;
%left RBRACE;
%left LBRACK;       //check where and which token L/R BRACK needs
%left RBRACK;       //^same^
%right ASSIGN;
%nonassoc RELOP;
%left BINOP;
%token ID;
%token NUM;
%token STRING;


%%

//Rules

Program: Funcs {
    Node* prog = new Program((FuncList*)$1);
    printScope(TableStack.top());
    OffsetStack.pop();
    TableStack.pop();
    delete prog;
};

Funcs: FuncDecl Funcs { $$ = new FuncList((FuncList*)$2, (Func*)$1); }
       | /*epsilon*/ { $$ = new FuncList(); }
;

FuncDecl: RetType UpdateCurrentFunName LPAREN Formals AddFuncSymbol RPAREN NewFunctionScope LBRACE Statements RBRACE {  //moved NewFunctionScope one right
    Func* func = new Func((RetType*)$1, (Id*)$2, (Formals*)$4, (Statements*)$9);
    $$ = func;
    printScope(scopes.top());
    OffsetStack.pop();
    TableStack.pop();
};

RetType: VOID {
    RetType* type = new RetType((Void*)$1);
    $$ = type;
    expectedRet = type;      //updates the expected return type to VOID
};


RetType: Type {
    RetType* type = new RetType((Type*)$1);
    $$ = type;
    expectedRet =type;      //updates the expected return type accord.
};

UpdateCurrentFunName: ID {
    currentFunName = (Id*)$1;
    $$ = $1;
}

AddFuncSymbol: {
    addFuncSymbol(SymbolTable, OffsetStack, expectedRet, currentFunName, currentFunParams, yylineno);
}

NewFunctionScope: {
    addScope(TableStack, OffsetStack);    //opens a new scope for function
    addFormalsToScope(TableStack, OffsetStack, currentFunParams, yylineno); 
};

Formals: {
    Formals* params = new Formals();
    $$ = params;
    currentFunParams = params; //no parameters for the current func
};

Formals: FormalsList{
    Formals* params = new Formals((FormalsList*)$1);
    $$ = params;
    currentFunParams = params;
};

FormalsList: FormalDecl { $$ = new FormalsList((FormalDecl*)$1); }
            | FormalDecl COMMA FormalsList{ $$ = new FormalsList((FormalsList*)$3, (FormalDecl*)$1); } //updates the current func parameters
;

FormalDecl: Type ID{ $$ = new FormalDecl((Type*)$1, (Id*)$2); }
            | Type ID LBRACK NUM RBRACK { $$ = new FormalDecl((Type*)$1, (Id*)$2,(Num*)$4); }       //array function 
            | Type ID LBRACK NUM B RBRACK { $$ = new FormalDecl((Type*)$1, (Id*)$2,(Num*)$4, (B*)$5); }     //array function  
;

Statements: Statement { $$ = new Statements((Statement*)$1); }
            | Statements Statement { $$ = new Statements((Statements*)$1, (Statement*)$2); }
;

Statement: LBRACE AddNewScope Statements RBRACE {
    $$ = new Statement((Statements*)$3);
    printScope(TableStack.top());
    scopes.pop();
    offsets.pop();
};

AddNewScope: {
    addScope(TableStack, OffsetStack);     //opens a new scope
};

//dec a new variable and add it to scope
Statement: Type ID SC {
    $$ = new Statement((Type*) $1, (Id*)$2);
    newVarScope(TableStack, OffsetStack, (Type*) $1, (Id*) $2, yylineno);
};

//dec and assign to a new variable and add it to scope
Statement: Type ID ASSIGN Exp SC {
    $$ = new Statement((Type*) $1, (Id*)$2, (Exp*)$4);
    newVarScope(TableStack, OffsetStack, (Type*) $1, (Id*) $2, yylineno);
};

//dec of a new int array 
Statement: Type ID LBRACK NUM RBRACK SC {
    Type temp(*((Type*)$1));
    int val=((Num*)$4)->value;
    temp.isArray=true;
    temp.size=val;
    $$ = new Statement(&temp, (Id*)$2, (Num*)$4);
    newVarScope(TableStack, OffsetStack, &temp, (Id*) $2, yylineno);
};

//dec of a new byte array       
Statement: Type ID LBRACK NUM B RBRACK SC {
        Type temp(*((Type*)$1));
        int val=((Num*)$4)->value;
        temp.isArray=true;
        temp.size=val;
        $$ = new Statement(&temp, (Id*)$2, (Num*)$4, (B*)$5);
        newVarScope(TableStack, OffsetStack, &temp, (Id*) $2, yylineno);
};

//assign to variable
Statement: ID ASSIGN Exp SC {
    $$ = new Statement((Id*)$1, (Exp*)$3);
};

//assign to an array 
Statement: ID LBRACK checkArrayIndexType RBRACK ASSIGN Exp SC {
    $$ = new Statement((Id*)$1, (Exp*)$3, (Exp*)$6);
};

//function call
Statement: Call SC {
    $$ = new Statement((Call*)$1);
};

//simple return - only in void functions! check salso size for array type
Statement: RETURN SC {
    if(expectedRet->type == "VOID"){ //is a void func
        $$ = new Statement();
    }else{
        errorMismatch(yylineno);
        exit(0);
    }
};

//return with a type - accord to the func type -- check salso size for array type  -need to update!
Statement: RETURN Exp SC {
    if(expectedRet->type != ((Exp*)$2)->type){
        if((expectedRet->type != "INT" && ((Exp*)$2)->type != "BYTE") ) { //allowed cast from byte to int
            errorMismatch(yylineno);
            exit(0);
        }
    }
    if(expectedRet->type != "VOID"){ //not a void func    
    $$ = new Statement((Exp*)$2);
    }
};

//if statement
Statement: IF LPAREN checkExpType RPAREN AddNewScope Statement ExitScope {
    $$ = new Statement((Exp*)$3, (Statement*)$6);
};

//exits the current scope
ExitScope: {
    printScope(TableStack.top());
    OffsetStack.pop();
    TableStack.pop();
};

//if statement with an else
Statement: IF LPAREN checkExpType RPAREN AddNewScope Statement ExitScope ELSE AddNewScope Statement {
    $$ = new Statement((Exp*)$3, (Statement*)$6, (Statement*)$10);
    printScope(TableStack.top());
    OffsetStack.pop();
    TableStack.pop();
};

//while loop
Statement: WHILE AddWhileScope LPAREN checkExpType RPAREN AddNewScope Statement {
    $$ = new Statement((Exp*)$4, (Statement*)$7);
    printScope(TableStack.top());
    OffsetStack.pop();
    TableStack.pop();
    whileScopes--;  //exits the while scope
};

//check if the expression is BOOL  in IF/While
checkExpType: Exp {
    if(((Exp*)$1)->type != "BOOL"){
        errorMismatch(yylineno);
        exit(0);
    }
};

//[X] - checks if the X type is a num  ~~~~~~~~~~~~~~~~~~~ add size!=1 check after we add it!
checkArrayIndexType: Exp {
    if((((Exp*)$1)->type.type != "INT") && (((Exp*)$1)->type.type != "BYTE")){
        errorMismatch(yylineno);
        exit(0);
    }
};

//while scopes counter for the break command
AddWhileScope: {
    whileScopes++;
};

//break command
Statement: BREAK SC {
    if(whileScopes == 0){        //checks if it's in atleast one while scope
        errorUnexpectedBreak(yylineno);
        exit(0);
    }else{
        $$ = new Statement();
    }
};

//checks function id for a special case of print function
FuncName: ID {
    $$ = $1;
    if(((Id*)$1)->text == "print"){   //checks if the func is *print* for special case (- can accept string after it
        isAprintFunc = true;                
    }
};

//calls function with parameters
Call: FuncName LPAREN ExpList RPAREN {
    $$ = new Call((Id*)$1, (ExpList*)$3);
    isAprintFunc = false;        //back to default status        
};

//calls function without parameters
Call: FuncName LPAREN RPAREN {
    $$ = new Call((Id*)$1);
};

ExpList: Exp { $$ = new ExpList((Exp*)$1); }
        | Exp COMMA ExpList { $$ = new ExpList((Exp*)$1, (ExpList*)$3); }
;

Type: INT  { $$ = new Type((Int*)$1); }
    | BYTE { $$ = new Type((Byte*)$1); }
    | BOOL { $$ = new Type((Bool*)$1); }
;


Exp: LPAREN Exp RPAREN { $$ = new Exp((Exp*)$2); }
    | ID LBRACK checkArrayIndexType RBRACK { $$ = new Exp((Id*)$1, (Exp*)$3,true); }        //array var 
    | Exp BINOP Exp { $$ = new Exp((Exp*)$1, (Binop*)$2, (Exp*)$3); }
    | ID { $$ = new Exp((Id*)$1); }
    | Call { $$ = new Exp((Call*)$1); }
    | NUM { $$ = new Exp((Num*)$1); }
    | NUM B { $$ = new Exp((Num*)$1, (B*)$2); }
    | STRING { $$ = new Exp((String*)$1); }
    | TRUE { $$ = new Exp((True*)$1); }
    | FALSE { $$ = new Exp((False*)$1); }
    | NOT Exp { $$ = new Exp((Not*)$1, (Exp*)$2); }
    | Exp AND Exp { $$ = new Exp((Exp*)$1, (And*)$2, (Exp*)$3); }
    | Exp OR Exp { $$ = new Exp((Exp*)$1,  (Or*)$2,  (Exp*)$3); }
    | Exp RELOP Exp { $$ = new Exp((Exp*)$1,  (Relop*)$2,  (Exp*)$3); }
};

%%

//User Routines

void yyerror(const char*) {
    errorSyn(yylineno); //Syntax Error
    exit(0);
}

int main(){
    whileScopes=0;
    isAprintFunc=false;
    StacksInit(TableStack, OffsetStack);
    return yyparse();
}